<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>VideoGroundQA</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0f1115; --fg:#e8eaf0; --muted:#9aa0aa; --accent:#00c8ff; --accent2:#ff6b6b; --accent3:#51cf66; }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--fg); font:14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    header { padding:14px 20px; border-bottom:1px solid #22252a; background:#0a0d12; }
    main { display:grid; grid-template-columns: 280px 1fr; gap:16px; padding:16px; min-height:calc(100vh - 60px); }

    .card { background:#141820; border:1px solid #22252a; border-radius:8px; padding:14px; margin-bottom:12px; }
    .card-title { font-weight:600; margin-bottom:10px; font-size:13px; text-transform:uppercase; letter-spacing:0.5px; color:var(--accent); }

    .row { display:flex; gap:8px; align-items:center; }
    .row > * { flex:0 0 auto; }
    .row .grow { flex:1 1 auto; }
    .col { display:flex; flex-direction:column; gap:8px; }

    select, input, textarea, button { background:#0c0f14; color:var(--fg); border:1px solid #2a2f38; border-radius:6px; padding:9px 12px; font:inherit; }
    input::placeholder, textarea::placeholder { color:var(--muted); }
    textarea { resize:vertical; min-height:60px; font-family:inherit; }
    button { cursor:pointer; transition:all 0.2s; font-weight:500; }
    button:hover:not([disabled]) { background:#141820; border-color:var(--accent); }
    button[disabled] { opacity:0.5; cursor:not-allowed; }
    button.primary { background:var(--accent); color:#000; border-color:var(--accent); }
    button.primary:hover:not([disabled]) { background:#00aad4; }
    button.secondary { background:var(--accent3); color:#000; border-color:var(--accent3); }
    button.secondary:hover:not([disabled]) { background:#45b85a; }

    .list { max-height:420px; overflow:auto; border-radius:6px; border:1px solid #2a2f38; background:#0a0d12; }
    .list-item { padding:10px 12px; cursor:pointer; border-bottom:1px solid #1b1f27; transition:background 0.15s; }
    .list-item:last-child { border-bottom:none; }
    .list-item:hover { background:#171c26; }
    .list-item.active { background:#1d2532; border-left:3px solid var(--accent); padding-left:9px; }

    .query-item { padding:8px 12px; background:#0c0f14; border:1px solid #2a2f38; border-radius:6px; cursor:pointer; transition:all 0.15s; margin-bottom:6px; }
    .query-item:hover { background:#141820; border-color:var(--accent); }
    .query-item.selected { border-color:var(--accent3); background:#1a2820; }

    .tabs { display:flex; gap:4px; border-bottom:1px solid #2a2f38; margin-bottom:12px; }
    .tab { padding:8px 16px; cursor:pointer; border-bottom:2px solid transparent; transition:all 0.2s; }
    .tab:hover { background:#141820; }
    .tab.active { border-bottom-color:var(--accent); color:var(--accent); font-weight:600; }
    .tab-content { display:none; }
    .tab-content.active { display:block; }

    .content-grid { display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
    .content-left { display:flex; flex-direction:column; }
    .content-right { display:flex; flex-direction:column; }

    .player-wrap { position:relative; background:#0b0d12; border:1px solid #22252a; border-radius:8px; overflow:hidden; aspect-ratio:16/9; width:100%; }
    video { display:block; width:100%; height:100%; background:black; object-fit:contain; }
    canvas.overlay { position:absolute; inset:0; pointer-events:none; }
    canvas.timeline { width:100%; height:48px; display:block; margin-top:10px; background:#11151d; border-radius:6px; border:1px solid #22252a; }

    .meta { color:var(--muted); font-size:12px; margin-top:6px; }
    .status { padding:8px 12px; background:#0c0f14; border:1px solid #2a2f38; border-radius:6px; font-size:13px; }
    .status.error { background:#3d1414; border-color:#ff6b6b; color:#ff6b6b; }
    .status.success { background:#143d1a; border-color:var(--accent3); color:var(--accent3); }
    .status.loading { background:#1a2d3d; border-color:var(--accent); color:var(--accent); }

    .qa-answer { padding:12px; background:#0c0f14; border:1px solid #2a2f38; border-radius:6px; margin-top:10px; line-height:1.6; white-space:pre-wrap; max-height:300px; overflow-y:auto; }

    .badge { display:inline-block; padding:2px 8px; background:var(--accent); color:#000; border-radius:4px; font-size:11px; font-weight:600; }

    ::-webkit-scrollbar { width:8px; height:8px; }
    ::-webkit-scrollbar-track { background:#0a0d12; }
    ::-webkit-scrollbar-thumb { background:#2a2f38; border-radius:4px; }
    ::-webkit-scrollbar-thumb:hover { background:#3a3f49; }
  </style>
</head>
<body>
  <header>
    <div class="row">
      <div class="grow"><strong style="font-size:16px;">VideoGroundQA</strong></div>
    </div>
  </header>

  <main>
    <!-- Left Sidebar -->
    <aside>
      <div class="card">
        <div class="row" style="margin-bottom:10px">
          <div class="card-title">Videos</div>
          <div class="grow"></div>
          <button id="refresh" style="padding:6px 10px; font-size:12px;">Refresh</button>
        </div>
        <div id="videoList" class="list"></div>
      </div>
    </aside>

    <!-- Main Content -->
    <section>
      <!-- Unified Interface -->
      <div class="content-grid">
        <!-- Left: Controls -->
        <div class="content-left">
          <!-- Grounding Query Section -->
          <div class="card">
            <div class="card-title">Grounding Query</div>
            <div class="col" style="gap:10px">
              <input id="query" placeholder="Enter query (e.g., 'the man in blue jacket')" />
              <button id="run" class="primary">Run Grounding</button>
              <button id="genQueries" class="secondary">Generate Queries</button>
            </div>
            <div id="statusGround" class="status" style="margin-top:10px; display:none;"></div>
          </div>

          <!-- Generated Queries -->
          <div class="card" id="queriesCard" style="display:none;">
            <div class="card-title">Generated Queries (Click to use)</div>
            <div id="generatedQueries" class="col" style="max-height:400px; overflow-y:auto;"></div>
          </div>

          <!-- Question Answering Section -->
          <div class="card">
            <div class="card-title">Question Answering</div>
            <div class="col" style="gap:10px">
              <input id="qaQuestion" placeholder="Ask a question about the video (e.g., 'What is happening in this video?')" />
              <button id="askQuestionFull" class="primary">Ask Question on Full Video</button>
              <button id="askQuestionSegment" class="secondary" disabled>Ask Question on Grounded Segment</button>
            </div>
            <div id="statusQA" class="status" style="margin-top:10px; display:none;"></div>
          </div>

          <!-- Answer Display -->
          <div class="card" id="qaAnswerCard" style="display:none;">
            <div class="card-title">Answer</div>
            <div id="qaAnswer" class="qa-answer"></div>
          </div>
        </div>

        <!-- Right: Video -->
        <div class="content-right">
          <div class="player-wrap">
            <video id="player" controls crossorigin="anonymous"></video>
            <canvas id="overlay" class="overlay"></canvas>
          </div>
          <canvas id="timeline" class="timeline"></canvas>
          <div class="meta" id="meta"></div>
        </div>
      </div>
    </section>
  </main>

  <script>
    const el = (id) => document.getElementById(id);

    // Elements
    const listEl = el('videoList');
    const player = el('player');
    const overlay = el('overlay');
    const timeline = el('timeline');
    const metaEl = el('meta');
    const statusGroundEl = el('statusGround');
    const statusQAEl = el('statusQA');
    const runBtn = el('run');
    const refreshBtn = el('refresh');
    const queryEl = el('query');
    const genQueriesBtn = el('genQueries');
    const generatedQueriesEl = el('generatedQueries');
    const queriesCard = el('queriesCard');
    const qaQuestionEl = el('qaQuestion');
    const askQuestionFullBtn = el('askQuestionFull');
    const askQuestionSegmentBtn = el('askQuestionSegment');
    const qaAnswerCard = el('qaAnswerCard');
    const qaAnswerEl = el('qaAnswer');

    // State
    let videos = [];
    let active = null;
    let result = null;
    let tubeMap = {};
    let fps = 30;
    let totalFrames = 0;
    let temporal = null;
    let naturalW = 0, naturalH = 0;
    let generatedQueries = [];

    // Video list
    function renderList() {
      listEl.innerHTML = '';
      if (videos.length === 0) {
        listEl.innerHTML = '<div style="padding:20px; text-align:center; color:var(--muted);">No videos found</div>';
        return;
      }
      videos.forEach(name => {
        const div = document.createElement('div');
        div.className = 'list-item' + (active === name ? ' active' : '');
        div.textContent = name;
        div.onclick = () => selectVideo(name);
        listEl.appendChild(div);
      });
    }

    async function loadVideos() {
      try {
        const r = await fetch('/api/videos');
        const data = await r.json();
        videos = data.files || [];
        renderList();
      } catch (e) {
        console.error('Failed to load videos:', e);
      }
    }

    async function selectVideo(name) {
      active = name;
      renderList();

      const url = `/videos/${encodeURIComponent(name)}`;
      player.src = url;
      result = null;
      tubeMap = {};
      temporal = null;
      generatedQueries = [];
      queriesCard.style.display = 'none';
      qaAnswerCard.style.display = 'none';
      hideStatus(statusGroundEl);
      hideStatus(statusQAEl);
      metaEl.textContent = '';

      // Disable segment QA button when selecting new video
      askQuestionSegmentBtn.disabled = true;

      // Load meta
      try {
        const r = await fetch(`/api/meta?video=${encodeURIComponent(name)}`);
        const data = await r.json();
        fps = data.fps || 30;
        totalFrames = data.total_frames || 0;
        naturalW = data.width || 0;
        naturalH = data.height || 0;
        const info = `${fps.toFixed(2)} fps · ${totalFrames} frames · ${naturalW}×${naturalH}`;
        metaEl.textContent = info;
      } catch {
        fps = 30; totalFrames = 0; naturalW = naturalH = 0;
      }
    }

    // Status helpers
    function showStatus(el, msg, type = 'loading') {
      el.textContent = msg;
      el.className = `status ${type}`;
      el.style.display = 'block';
    }

    function hideStatus(el) {
      el.style.display = 'none';
    }

    // Generate Queries
    async function generateQueries() {
      if (!active) { alert('Please select a video first'); return; }

      genQueriesBtn.disabled = true;
      showStatus(statusGroundEl, 'Generating queries using QA model...', 'loading');

      try {
        const r = await fetch('/api/generate-queries', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ video: active, num_queries: 10, num_frames: 64, max_tokens: 300 })
        });

        if (!r.ok) throw new Error(`HTTP ${r.status}: ${await r.text()}`);

        const data = await r.json();
        generatedQueries = data.queries || [];

        if (generatedQueries.length === 0) {
          showStatus(statusGroundEl, 'No queries generated', 'error');
          return;
        }

        renderGeneratedQueries();
        queriesCard.style.display = 'block';
        showStatus(statusGroundEl, `Generated ${generatedQueries.length} queries`, 'success');
      } catch (e) {
        showStatus(statusGroundEl, `Failed: ${e.message}`, 'error');
        console.error(e);
      } finally {
        genQueriesBtn.disabled = false;
      }
    }

    function renderGeneratedQueries() {
      generatedQueriesEl.innerHTML = '';
      generatedQueries.forEach((q, i) => {
        const div = document.createElement('div');
        div.className = 'query-item';
        div.textContent = `${i + 1}. ${q}`;
        div.onclick = () => {
          queryEl.value = q;
          document.querySelectorAll('.query-item').forEach(el => el.classList.remove('selected'));
          div.classList.add('selected');
          showStatus(statusGroundEl, `Query selected: "${q}"`, 'success');
        };
        generatedQueriesEl.appendChild(div);
      });
    }

    // Run Grounding
    async function runInference() {
      if (!active) { alert('Please select a video first'); return; }
      const q = (queryEl.value || '').trim();
      if (!q) { alert('Please enter or select a query'); return; }

      runBtn.disabled = true;
      showStatus(statusGroundEl, 'Running grounding inference...', 'loading');

      try {
        const r = await fetch('/api/predict', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ video: active, query: q, device: 'auto' })
        });

        if (!r.ok) throw new Error(await r.text());

        const data = await r.json();
        result = data;
        fps = (data.meta && data.meta.fps) || fps;
        totalFrames = (data.meta && data.meta.total_frames) || totalFrames;
        naturalW = (data.meta && data.meta.width) || naturalW;
        naturalH = (data.meta && data.meta.height) || naturalH;
        temporal = data.result && data.result.temporal ? data.result.temporal : null;
        buildTubeMap(data.result ? data.result.tube : []);

        if (temporal) {
          showStatus(statusGroundEl, `Grounded: ${temporal.start.toFixed(2)}s → ${temporal.end.toFixed(2)}s`, 'success');
          player.currentTime = temporal.start;

          // Enable segment QA button when grounding succeeds
          askQuestionSegmentBtn.disabled = false;
        } else {
          showStatus(statusGroundEl, 'Inference complete', 'success');
          // Disable if no temporal bounds found
          askQuestionSegmentBtn.disabled = true;
        }

        drawTimeline();
      } catch (e) {
        showStatus(statusGroundEl, `Failed: ${e}`, 'error');
        console.error(e);
        // Disable button on error
        askQuestionSegmentBtn.disabled = true;
      } finally {
        runBtn.disabled = false;
      }
    }

    // Video QA - Full Video
    async function askQuestionFull() {
      if (!active) { alert('Please select a video first'); return; }
      const question = (qaQuestionEl.value || '').trim();
      if (!question) { alert('Please enter a question'); return; }

      askQuestionFullBtn.disabled = true;
      qaAnswerCard.style.display = 'none';
      showStatus(statusQAEl, 'Thinking about full video...', 'loading');

      try {
        const r = await fetch('/api/qa', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            video: active,
            question: question,
            num_frames: 32,
            max_tokens: 256
          })
        });

        if (!r.ok) throw new Error(await r.text());

        const data = await r.json();
        const answer = data.answer || 'No answer received';

        qaAnswerEl.textContent = answer;
        qaAnswerCard.style.display = 'block';
        showStatus(statusQAEl, 'Answer generated (Full Video)', 'success');
      } catch (e) {
        showStatus(statusQAEl, `Failed: ${e}`, 'error');
        console.error(e);
      } finally {
        askQuestionFullBtn.disabled = false;
      }
    }

    // Video QA - Grounded Segment
    async function askQuestionSegment() {
      if (!active) { alert('Please select a video first'); return; }
      if (!temporal) { alert('No grounded segment available. Run grounding first.'); return; }
      const question = (qaQuestionEl.value || '').trim();
      if (!question) { alert('Please enter a question'); return; }

      askQuestionSegmentBtn.disabled = true;
      qaAnswerCard.style.display = 'none';
      showStatus(statusQAEl, `Thinking about segment ${temporal.start.toFixed(2)}s-${temporal.end.toFixed(2)}s...`, 'loading');

      try {
        const r = await fetch('/api/qa', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            video: active,
            question: question,
            bound_start: temporal.start,
            bound_end: temporal.end,
            num_frames: 32,
            max_tokens: 256
          })
        });

        if (!r.ok) throw new Error(await r.text());

        const data = await r.json();
        const answer = data.answer || 'No answer received';

        qaAnswerEl.textContent = answer;
        qaAnswerCard.style.display = 'block';
        showStatus(statusQAEl, `Answer generated (Segment: ${temporal.start.toFixed(2)}s-${temporal.end.toFixed(2)}s)`, 'success');
      } catch (e) {
        showStatus(statusQAEl, `Failed: ${e}`, 'error');
        console.error(e);
      } finally {
        askQuestionSegmentBtn.disabled = false;
      }
    }

    // Drawing functions
    function resizeOverlayToPlayer() {
      const rect = player.getBoundingClientRect();
      overlay.width = Math.round(rect.width);
      overlay.height = Math.round(rect.height);
      overlay.style.width = rect.width + 'px';
      overlay.style.height = rect.height + 'px';
    }

    function drawOverlay() {
      const ctx = overlay.getContext('2d');
      ctx.clearRect(0, 0, overlay.width, overlay.height);
      if (!result || !fps || !naturalW || !naturalH) return;

      const t = player.currentTime || 0;
      const frame = Math.round(t * fps);
      const rec = tubeMap[frame];
      const withinTemporal = !temporal || (t >= (temporal.start - 1e-6) && t <= (temporal.end + 1e-6));

      if (!rec || !withinTemporal) return;
      const [x1, y1, x2, y2] = rec.bbox;
      const score = rec.score;

      const dispW = overlay.width;
      const dispH = overlay.height;
      const scale = Math.min(dispW / naturalW, dispH / naturalH);
      const newW = naturalW * scale;
      const newH = naturalH * scale;
      const offX = (dispW - newW) / 2;
      const offY = (dispH - newH) / 2;

      const sx = offX + x1 * scale;
      const sy = offY + y1 * scale;
      const ex = offX + x2 * scale;
      const ey = offY + y2 * scale;

      ctx.save();
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#00c8ff';
      ctx.shadowBlur = 8;
      ctx.shadowColor = '#00c8ff';
      ctx.beginPath();
      ctx.rect(sx, sy, ex - sx, ey - sy);
      ctx.stroke();

      const label = score.toFixed(2);
      ctx.shadowBlur = 0;
      ctx.font = 'bold 13px system-ui';
      const tw = ctx.measureText(label).width;
      const th = 20;
      ctx.fillStyle = '#00c8ff';
      ctx.fillRect(sx, Math.max(0, sy - th - 4), tw + 10, th);
      ctx.fillStyle = '#000';
      ctx.fillText(label, sx + 5, Math.max(14, sy - 8));
      ctx.restore();
    }

    function drawTimeline() {
      const ctx = timeline.getContext('2d');
      const w = timeline.width = timeline.clientWidth;
      const h = timeline.height = timeline.clientHeight;

      ctx.clearRect(0, 0, w, h);
      const barH = 12;
      const y = (h - barH) / 2;

      ctx.fillStyle = '#2a2f38';
      ctx.fillRect(12, y, w - 24, barH);

      if (temporal && totalFrames && fps) {
        const totalS = totalFrames / fps;
        const x0 = 12 + (w - 24) * (temporal.start / Math.max(1e-6, totalS));
        const x1 = 12 + (w - 24) * (temporal.end / Math.max(1e-6, totalS));
        ctx.fillStyle = '#00c8ff';
        ctx.fillRect(x0, y, x1 - x0, barH);
      }

      if (fps) {
        const totalS = totalFrames ? (totalFrames / fps) : (player.duration || 0);
        const x = 12 + (w - 24) * ((player.currentTime || 0) / Math.max(1e-6, totalS));
        ctx.fillStyle = '#fff';
        ctx.fillRect(x - 2, y - 8, 4, barH + 16);
      }
    }

    function buildTubeMap(tube) {
      tubeMap = {};
      (tube || []).forEach(item => {
        if (!('frame' in item) || !('bbox' in item)) return;
        tubeMap[Number(item.frame)] = { bbox: item.bbox, score: Number(item.score || 1.0) };
      });
    }

    // Events
    window.addEventListener('resize', () => { resizeOverlayToPlayer(); drawOverlay(); drawTimeline(); });
    player.addEventListener('loadedmetadata', () => { resizeOverlayToPlayer(); drawOverlay(); drawTimeline(); });
    player.addEventListener('timeupdate', () => { drawOverlay(); drawTimeline(); });
    player.addEventListener('seeked', () => { drawOverlay(); drawTimeline(); });
    runBtn.addEventListener('click', runInference);
    genQueriesBtn.addEventListener('click', generateQueries);
    askQuestionFullBtn.addEventListener('click', askQuestionFull);
    askQuestionSegmentBtn.addEventListener('click', askQuestionSegment);
    refreshBtn.addEventListener('click', loadVideos);

    // Init
    (async () => {
      await loadVideos();
    })();
  </script>
</body>
</html>
